"use strict";(self.webpackChunkclickhouse=self.webpackChunkclickhouse||[]).push([[58740],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return p}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),f=c(n),p=r,m=f["".concat(l,".").concat(p)]||f[p]||d[p]||i;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=f;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},88346:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return d}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),s=["components"],o={slug:"/en/manage/tuning-for-cloud-cost-efficiency",sidebar_position:63,sidebar_label:"Tuning for Cloud Cost Efficiency",title:"Tuning for Cloud Cost Efficiency"},l=void 0,c={unversionedId:"en/manage/tuning-for-cloud-cost-efficiency",id:"en/manage/tuning-for-cloud-cost-efficiency",title:"Tuning for Cloud Cost Efficiency",description:"ClickHouse Cloud is using cloud object storage for your data. Write requests to object storage are more expensive than read requests. Here are some tips for minimizing the amount of write requests in ClickHouse Cloud.",source:"@site/docs/en/manage/tuning-for-cloud-cost-efficiency.md",sourceDirName:"en/manage",slug:"/en/manage/tuning-for-cloud-cost-efficiency",permalink:"/docs/en/manage/tuning-for-cloud-cost-efficiency",draft:!1,editUrl:"https://github.com/ClickHouse/clickhouse-docs/blob/main/docs/en/manage/tuning-for-cloud-cost-efficiency.md",tags:[],version:"current",sidebarPosition:63,frontMatter:{slug:"/en/manage/tuning-for-cloud-cost-efficiency",sidebar_position:63,sidebar_label:"Tuning for Cloud Cost Efficiency",title:"Tuning for Cloud Cost Efficiency"},sidebar:"english",previous:{title:"Monitoring",permalink:"/docs/en/operations/monitoring"},next:{title:"Replication and Sharding",permalink:"/docs/en/manage/replication-and-sharding"}},u={},d=[{value:"Ingest data in bulk",id:"ingest-data-in-bulk",level:2},{value:"Insert data asynchronously",id:"insert-data-asynchronously",level:2},{value:"Avoid mutations",id:"avoid-mutations",level:2},{value:"Avoid using OPTIMIZE FINAL",id:"avoid-using-optimize-final",level:2},{value:"Avoid using Nullable column",id:"avoid-using-nullable-column",level:2}],f={toc:d};function p(e){var t=e.components,o=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},f,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"ClickHouse Cloud is using cloud object storage for your data. Write requests to object storage are more expensive than read requests. Here are some tips for minimizing the amount of write requests in ClickHouse Cloud."),(0,i.kt)("h2",{id:"ingest-data-in-bulk"},"Ingest data in bulk"),(0,i.kt)("p",null,"Batching data before writing can help reduce the number of write requests generated. As each insert creates a part together with other metadata that needs to be stored, increasing the size of each insert would reduce the number of writes required. Generally, we recommend inserting data in fairly large batches of at least 1,000 rows at a time, and ideally between 10,000 to 100,000 rows. To achieve this, consider implementing a buffer mechanism such as using Kafka in your application to enable batch inserts, or use asynchronous inserts (see ",(0,i.kt)("a",{parentName:"p",href:"#insert-data-asynchronously"},"next section"),")."),(0,i.kt)("p",null,"The advice to insert thousands of rows at a time is a starting point and should be adjusted based on the size of the rows.  MergeTree tables create ",(0,i.kt)("em",{parentName:"p"},"compact")," parts if the size of the insert is below 1GB, as set by ",(0,i.kt)("inlineCode",{parentName:"p"},"min_bytes_for_wide_part"),".  If the size of the insert exceeds that value, then ",(0,i.kt)("em",{parentName:"p"},"wide"),' parts are created, which are more expensive to process on the "Write Unit" pricing dimensions.  To check the related settings use this query:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\nFROM system.merge_tree_settings\nWHERE (name LIKE '%compact%') OR (name LIKE '%wide%')\n")),(0,i.kt)("p",null,"To check whether or not your parts are compact or wide:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"\nSELECT\n    database,\n    table,\n    part_type,\n    count() AS `Part Count`,\n    formatReadableSize(min(bytes_on_disk)) AS `Smallest Part`,\n    formatReadableSize(max(bytes_on_disk)) AS `Largest Part`\nFROM system.parts\nWHERE database != 'system'\nGROUP BY\n    database,\n    table,\n    part_type\nFORMAT Vertical\n")),(0,i.kt)("h2",{id:"insert-data-asynchronously"},"Insert data asynchronously"),(0,i.kt)("p",null,"Leverage ",(0,i.kt)("a",{parentName:"p",href:"https://clickhouse.com/blog/click-house-v2111-released"},"asynchronous inserts")," as an alternative to batching data on the client-side by enabling the ",(0,i.kt)("a",{parentName:"p",href:"../operations/settings/settings/#async-insert"},"async_insert")," setting. This causes ClickHouse to handle the batching on the server-side. Doing so will also reduce the number of write requests generated."),(0,i.kt)("p",null,"As mentioned in the previous section, each insert sent to ClickHouse causes ClickHouse to immediately create a part containing the data from the insert.\nThis is the default behavior when the async_insert setting is set to 0:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"compression block diagram",src:n(3361).Z,width:"2659",height:"1996"})),(0,i.kt)("p",null,"By setting async_insert to 1, ClickHouse first stores the incoming inserts into an in-memory buffer before flushing them regularly to disk. This asynchronous behavior allows ClickHouse to automatically batch your data up to 100KB (configurable via ",(0,i.kt)("a",{parentName:"p",href:"../operations/settings/settings/#async-insert-max-data-size"},"async_insert_max_data_size"),") or wait for 200ms (since the first insert) (configurable via ",(0,i.kt)("a",{parentName:"p",href:"../operations/settings/settings/#async-insert-max-data-size"},"async_insert_busy_timeout_ms"),") before writing the data to object store. This helps to reduce the amount of write requests for frequent inserts."),(0,i.kt)("p",null,"With the ",(0,i.kt)("a",{parentName:"p",href:"../operations/settings/settings/#wait-for-async-insert"},"wait_for_async_insert")," setting, you can configure if you want an insert statement to return with an acknowledgment either immediately after the data got inserted into the buffer (wait_for_async_insert = 0) or by default, after the data got written to a part after flushing from buffer (wait_for_async_insert = 1). "),(0,i.kt)("p",null,"The following two diagrams illustrate the two settings for async_insert and wait_for_async_insert:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"compression block diagram",src:n(13083).Z,width:"3564",height:"2117"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"compression block diagram",src:n(76097).Z,width:"3574",height:"2100"})),(0,i.kt)("p",null,"Note that asynchronous insert is only applicable when inserting over HTTP protocol."),(0,i.kt)("h2",{id:"avoid-mutations"},"Avoid mutations"),(0,i.kt)("p",null,"Mutations refers to ",(0,i.kt)("a",{parentName:"p",href:"../sql-reference/statements/alter/"},"ALTER")," queries that manipulate table data through deletion or updates. Most notably they are queries like ALTER TABLE \u2026 DELETE, UPDATE, etc. Performing such queries will produce new mutated versions of the data parts. This means that such statements would trigger a rewrite of whole data parts for all data that was inserted before the mutation, translating to a large amount of write requests."),(0,i.kt)("h2",{id:"avoid-using-optimize-final"},"Avoid using OPTIMIZE FINAL"),(0,i.kt)("p",null,"Using the ",(0,i.kt)("a",{parentName:"p",href:"../sql-reference/statements/optimize/"},"OPTIMIZE TABLE ... FINAL")," query will initiate an unscheduled merge of data parts for the specific table into one data part. During this process, ClickHouse reads all the data parts, uncompresses, merges, compresses them into a single part, and then rewrites back into object store, causing huge CPU and IO consumption. Note that this optimization rewrites the one part even if they are already merged into a single part."),(0,i.kt)("h2",{id:"avoid-using-nullable-column"},"Avoid using Nullable column"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"../sql-reference/data-types/nullable/"},"Nullable column")," (e.g. Nullable(UInt8)) creates a separate column of UInt8 type. This additional column has to be processed every time when user works with a nullable column. This leads to an additional storage space used and almost always negatively affects performance."))}p.isMDXComponent=!0},3361:function(e,t,n){t.Z=n.p+"assets/images/async-01-83309328e1c750b0da51c86692b85f74.png"},13083:function(e,t,n){t.Z=n.p+"assets/images/async-02-e01d1ed7002ee59d3287befd33f0cff7.png"},76097:function(e,t,n){t.Z=n.p+"assets/images/async-03-4f1ae9dae0e06c26b5363b2e12535d6c.png"}}]);